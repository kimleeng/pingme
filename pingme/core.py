# AUTOGENERATED! DO NOT EDIT! File to edit: ../00_core.ipynb.

# %% auto 0
__all__ = ['set_env_variables', 'Card', 'PingMe', 'resolved_payload', 'send_to_webhook', 'send_to_email', 'send_to_logfile',
           'cli']

# %% ../00_core.ipynb 9
# Inlcuded libraries, other libraries are included with the methods that use them.
# FIXME: Currently this is not showing in the docs, currently it seems no librs are
from fastcore.utils import patch # decorator to patch in new methods to a class

# %% ../00_core.ipynb 14
from dotenv import load_dotenv # for loading config from .env files

def set_env_variables(config_path) -> bool:
    # Order of precedence: environment variables > .env file > default values

    # Set the env vars first, this is needed for the card.yaml to replace ENV variables
    if config_path is not None:
        load_dotenv(config_path)
    load_dotenv("./config/config.default.env")

    return True


# %% ../00_core.ipynb 15
import os
set_env_variables(os.environ["PINGME_CONFIG_PATH"])

# %% ../00_core.ipynb 23
from pydantic import BaseModel
class Card(BaseModel):
    name: str
    context: dict

# %% ../00_core.ipynb 25
from pathlib import Path # for type hinting and file checking
import os
from envyaml import EnvYAML # Allows to loads env vars into a yaml file, https://github.com/thesimj/envyaml

class PingMe:
    """
    PingMe class which notifies via either a webhook or email
    """
    def __init__(self,
                 card: Card, # Card object
                 card_dir: Path, # Directory to look for cards in
                 card_ext: str=".yaml"): # Extension of card file
        self.card:Card = card
        self.card_path:Path = os.path.join(card_dir, f"{self.card.name+card_ext}") # built here to limit user options on api

        if not Path(self.card_path).is_file():
            raise ValueError(f"Payload file does not exist {self}")

        # Resolve config variables from ENV vars
        config:dict = EnvYAML(self.card_path, strict=False).export()
        self.email:dict = config["config"]["email"]
        self.webhook:dict = config["config"]["webhook"]
        self.logfile:dict = config["config"]["logfile"]
        # Resolve title and text from card.context
        self.title:str = self.card.context.get("title", "")
        self.text:str = self.card.context.get("text", "")
        # Resolve payload variables from card.context
        self.payload:json = resolved_payload(config["payload"]["value"], card.context)

    def __str__(self) -> str:
        return (
        f"""PingMe object with:
    card: {self.card}
    card_path: {self.card_path}
    payload:
{self.payload}"""
     )
    def __repr__(self) -> str:
        return self.__str__()

# %% ../00_core.ipynb 27
import re # regular expression for parsing
import json # to manage json payloads
@staticmethod
def resolved_payload(payload:json, context:dict) -> json:
    """
    Resolves the payload by substituting variables in the `payload` with values from the `context` and ensures all variables are accounted for
    """
    if payload is None:
        # Ensure there is a payload
        raise ValueError("Payload is None")
    str_temp = json.dumps(payload) # convert payload to string
    for key in context.keys():
        # Substitute all variables in payload with values from payload_context, it can also be set up that their are no variables in the payload
        str_temp = str_temp.replace("${"+key+"}", context[key])
    if re.search("\${.*}", str_temp):
        # Check if there are any variables left, this is not allowed
        raise ValueError("Unresolved variables in payload")
    return json.loads(str_temp)

# %% ../00_core.ipynb 31
import requests # to send requests to webhooks
@staticmethod
def send_to_webhook(url:str, payload:json, header:json={'Content-Type': 'application/json'}) -> dict:
    if url is None:
        raise Exception("Webhook URL not set")
    # Send message to webhook
    try:
        response = requests.post(url, data=payload, headers=header)
    except Exception as e:
        raise Exception(f"Error sending message to webhook: {e}")
    return {"status_code": response.status_code, "response": response.text}

# %% ../00_core.ipynb 33
@patch
def send_webhook(self:PingMe) -> dict:
    return send_to_webhook(self.webhook["url"], self.payload)

# %% ../00_core.ipynb 38
import smtplib # to send emails
import email.mime.text # to format emails

@staticmethod
def send_to_email(payload:json, subject:str, from_:str, to:str, host:str, port:int=25, user=None, password=None) -> dict:
    email_status = False
    html_content = f"""
    <html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
        <script type="application/adaptivecard+json">
            {payload}
        </script>
    </head>
        <body>
            This is a sample body
        </body>
    </html>
    """
    msg = email.mime.text.MIMEText(html_content, 'html')
    msg['Subject'] = subject
    msg['From'] = from_
    msg['To'] = to
    email_connection = smtplib.SMTP(host, port)
    try:
        email_connection.ehlo()
        email_connection.starttls()
        email_connection.ehlo()
        email_connection.login(user, password)
        email_connection.sendmail(from_, to, msg.as_string())
        email_status = True
    finally:
        email_connection.quit()
        return {"status_code":200, "response":email_status}


# %% ../00_core.ipynb 40
@patch
def send_email(self:PingMe) -> dict:
    return send_to_email(
        self.payload,
        self.title,
        self.email["from"],
        self.email["to"],
        self.email["smtp"]["host"],
        self.email["smtp"]["port"],
        self.email["smtp"]["user"],
        self.email["smtp"]["password"])

# %% ../00_core.ipynb 45
import datetime # to get current date and time which is used in logging

@staticmethod
def send_to_logfile(logfile:str, title:str, text:str) -> dict:
    """
    Send message to logfile
    TODO: The log file only lods title and text right now (not payload), while payload can be included it is not good for parsing. Need to think of a solution for this. Could be to save each payload as a seperate file and the log is a list of files.
    """
    if logfile is None:
        raise Exception("Log file not set")
    with open(logfile, "a") as f:
        # Write the current time
        f.write(f"{datetime.datetime.now()}\t{title}\t{text}\n")
        f.write("\n")
    return {"status_code":200, "response":True}

# %% ../00_core.ipynb 46
@patch
def send_logfile(self:PingMe) -> dict:
    return send_to_logfile(self.logfile["path"], self.title, self.text)

# %% ../00_core.ipynb 49
# Make a CLI function using `call_parse` to handle arguments
from sys import stderr
from fastcore.script import call_parse
import distutils.util # to convert string to bool
import json
import sys
# Ensure settings.ini contains `console_scripts = pingme=pingme.pingme:cli`, this makes the call as `pingme` and calls the cli function found in package pingme.pingme
@call_parse # https://fastcore.fast.ai/script.html#example
def cli(#TODO: fix params
    config_file:str,
    context:str,
    send_type:str,
    card_name:str = "default", # Name of the card which matches a card found in $PROJECTDIR/card_dir/
    card_dir:str = "./cards/",
    card_ext:str = ".yaml"
    ):
    """
    The Command Line Interface (CLI) for the pingme package. This is the main entry point for the package. Currently only allows for a config file to be provided, but can be extended to allow for args. Command line passing is handled with @call_parse decorator.
    """
    set_env_variables(config_file)
    context = json.loads(context)
    card = Card(name=card_name, context=context)
    pingme = PingMe(card=card, card_dir=card_dir, card_ext=card_ext)

    if send_type == "webhook":
        pingme.send_webhook()
        print("Sent to webhook", file=sys.stderr)
    if send_type == "email":
        pingme.send_email()
        print("Sent to email", file=sys.stderr)
    if send_type == "logfile":
        pingme.send_log_file()
        print("Sent to logfile", file=sys.stderr)

    return True
