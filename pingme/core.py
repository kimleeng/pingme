# AUTOGENERATED! DO NOT EDIT! File to edit: ../00_core.ipynb.

# %% auto 0
__all__ = ['set_env_variables', 'Card', 'PingMe', 'resolved_payload', 'send_to_webhook', 'send_to_email', 'send_to_logfile',
           'cli']

# %% ../00_core.ipynb 10
# Inlcuded libraries, other libraries are included with the methods that use them.
# FIXME: Currently this is not showing in the docs, currently it seems no librs are
from fastcore.utils import patch # decorator to patch in new methods to a class

# %% ../00_core.ipynb 15
from dotenv import load_dotenv # for loading config from .env files

def set_env_variables(config_path) -> bool:
    # Order of precedence: environment variables > .env file > default values

    # Set the env vars first, this is needed for the card.yaml to replace ENV variables
    if config_path is not None:
        load_dotenv(config_path)
    load_dotenv("./config/config.default.env")

    return True


# %% ../00_core.ipynb 16
import os
set_env_variables(os.environ.get("PINGME_CONFIG_PATH"))

# %% ../00_core.ipynb 24
from pydantic import BaseModel
class Card(BaseModel):
    name: str
    context: dict

# %% ../00_core.ipynb 26
from pathlib import Path # for type hinting and file checking
import os
from envyaml import EnvYAML # Allows to loads env vars into a yaml file, https://github.com/thesimj/envyaml

class PingMe:
    """
    PingMe class which notifies via either a webhook or email
    """
    def __init__(self,
                 card: Card, # Card object
                 card_dir: Path, # Directory to look for cards in
                 card_ext: str=".yaml"): # Extension of card file
        self.card:Card = card
        self.card_path:Path = os.path.join(card_dir, f"{self.card.name+card_ext}") # built here to limit user options on api

        if not Path(self.card_path).is_file():
            raise ValueError(f"Payload file does not exist {self}")

        # Resolve config variables from ENV vars
        config:dict = EnvYAML(self.card_path, strict=False).export()
        self.email:dict = config["config"]["email"]
        self.webhook:dict = config["config"]["webhook"]
        self.logfile:dict = config["config"]["logfile"]
        # Resolve title and text from card.context
        self.title:str = self.card.context.get("title", "")
        self.text:str = self.card.context.get("text", "")
        # Resolve payload variables from card.context, defined below
        self.payload:json = resolved_payload(config["payload"]["value"], card.context)

    def __str__(self) -> str:
        return (
        f"""PingMe object with:
    card: {self.card}
    card_path: {self.card_path}
    payload:
{self.payload}"""
     )
    def __repr__(self) -> str:
        return self.__str__()

# %% ../00_core.ipynb 28
import re # regular expression for parsing
import json # to manage json payloads
@staticmethod
def resolved_payload(payload:json, context:dict) -> json:
    """
    Resolves the payload by substituting variables in the `payload` with values from the `context` and ensures all variables are accounted for
    """
    if payload is None:
        # Ensure there is a payload
        raise ValueError("Payload is None")
    str_temp = json.dumps(payload) # convert payload to string
    for key in context.keys():
        # Substitute all variables in payload with values from payload_context, it can also be set up that their are no variables in the payload
        str_temp = str_temp.replace("${"+key+"}", context[key])
    if re.search("\${.*}", str_temp):
        # Check if there are any variables left, this is not allowed
        raise ValueError("Unresolved variables in payload")
    return json.loads(str_temp)

# %% ../00_core.ipynb 32
import requests # to send requests to webhooks
@staticmethod
def send_to_webhook(url:str, payload:json, header:json={'Content-Type': 'application/json'}) -> dict:
    if url is None:
        raise Exception("Webhook URL not set")
    # Send message to webhook
    try:
        response = requests.post(url, data=payload, headers=header)
    except Exception as e:
        raise Exception(f"Error sending message to webhook: {e}")
    return {"status_code": response.status_code, "response": response.text}

# %% ../00_core.ipynb 34
@patch
def send_webhook(self:PingMe) -> dict:
    return send_to_webhook(self.webhook["url"], self.payload)

# %% ../00_core.ipynb 39
import smtplib # to send emails
import email.mime.text # to format emails

@staticmethod
def send_to_email(payload:json, subject:str, from_:str, to:str, host:str, port:int=25, user=None, password=None) -> dict:
    email_status = False
    html_content = f"""
    <html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
        <script type="application/adaptivecard+json">
            {payload}
        </script>
    </head>
        <body>
            This is a sample body
        </body>
    </html>
    """
    msg = email.mime.text.MIMEText(html_content, 'html')
    msg['Subject'] = subject
    msg['From'] = from_
    msg['To'] = to
    email_connection = smtplib.SMTP(host, port)
    try:
        email_connection.ehlo()
        email_connection.starttls()
        email_connection.ehlo()
        email_connection.login(user, password)
        email_connection.sendmail(from_, to, msg.as_string())
        email_status = True
    finally:
        email_connection.quit()
        return {"status_code":200, "response":email_status}


# %% ../00_core.ipynb 41
@patch
def send_email(self:PingMe) -> dict:
    return send_to_email(
        self.payload,
        self.title,
        self.email["from"],
        self.email["to"],
        self.email["smtp"]["host"],
        self.email["smtp"]["port"],
        self.email["smtp"]["user"],
        self.email["smtp"]["password"])

# %% ../00_core.ipynb 46
import datetime # to get current date and time which is used in logging

@staticmethod
def send_to_logfile(logfile:str, title:str, text:str) -> dict:
    """
    Send message to logfile
    TODO: The log file only lods title and text right now (not payload), while payload can be included it is not good for parsing. Need to think of a solution for this. Could be to save each payload as a seperate file and the log is a list of files.
    """
    if logfile is None:
        raise Exception("Log file not set")
    with open(logfile, "a") as f:
        # Write the current time
        f.write(f"{datetime.datetime.now()}\t{title}\t{text}\n")
        f.write("\n")
    return {"status_code":200, "response":True}

# %% ../00_core.ipynb 47
@patch
def send_logfile(self:PingMe) -> dict:
    return send_to_logfile(self.logfile["path"], self.title, self.text)

# %% ../00_core.ipynb 51
# Make a CLI function using `call_parse` to handle arguments
from sys import stderr
from fastcore.script import call_parse
import distutils.util # to convert string to bool
import json
import sys
# Ensure settings.ini contains `console_scripts = pingme=pingmeme:cli`, this makes the call as `pingme` and calls the cli function found in package pingme.pingme
@call_parse # https://fastcore.fast.ai/script.html#example
def cli(context:str, # string denoting a json object with context variables (e.g. '{"title":"Test Title", "text":"Test Text"}')
        webhook:bool, # attempts to send to webhook
        email:bool, # attempts to send to email
        logfile:bool, # attempts to send to logfile
        example:bool, # Runs with example params, if it doesn't work config values haven't been set properly
        config_file:str=None, # config file to set env vars from
        card_name:str="default", # Name of the card which matches a card found in {PROJECTDIR}/cards/{CARDNAME}.yaml
        card_dir:str="./cards/", # Directory where cards are stored
        card_ext:str=".yaml", # Extension of card files
    ):
    """
    PingMe send a notification to a webhook, email, or log file.\n\n
    Usage examples:
    - basic:
    pingme --context '{"title":"Test Title", "text":"Test Text"}' --webhook
    - advanced:
    pingme --config_file ./config/config.env --context '{"title":"Test Title", "text":"Test Text"}' --webhook --email --logfile --card_name default --card_dir ./cards/ --card_ext .yaml
    NOTE: Will require use of ./cards/default.yaml and ./config/config.default.env to be set up properly
    """
    set_env_variables(config_file)
    context = json.loads(context)
    card = Card(name=card_name, context=context)
    pingme = PingMe(card=card, card_dir=card_dir, card_ext=card_ext)

    if not webhook and not email and not logfile:
        print("No destination provided, exiting", file=stderr)
        return False
    else:
        if webhook:
            pingme.send_webhook()
            print("Sent to webhook", file=sys.stderr)
        if email:
            pingme.send_email()
            print("Sent to email", file=sys.stderr)
        if logfile:
            pingme.send_logfile()
            print("Sent to logfile", file=sys.stderr)

    return True
